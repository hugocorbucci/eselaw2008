\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage[latin1]{inputenc}
\usepackage{indentfirst}
\usepackage{lscape}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage{graphicx,url}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

\sloppy

\title{Open Source and Agile:\\Two worlds that should have a closer
  interaction}

\author{Hugo Corbucci\inst{1} and Alfredo Goldman\inst{1}}

\address{Instituto de Matemática e Estatística (IME)\\Universidade de São
  Paulo (USP) - Brazil
\email{\{corbucci,gold\}@ime.usp.br}
}

\begin{document}
 
\maketitle

\begin{abstract}
  Agile methods and open source software communities share similar
  cultures with different approaches to overcome problems. Although
  several professionals are involved in both worlds, neither agile
  methodologies are as strong as they could be in open source
  communities nor those communities provide strong contributions to
  agile methods. This work identifies and exposes the obstacles that
  separate those communities in order to extract the best of them and
  improve both sides with suggestions of tools and development
  processes.
\end{abstract}

\section{Introduction}

Typical Open Source (OS) projects usually receive the collaboration of
many geographically distant people \cite{Dempsey1999} and are
organized around a leader which is the top of the hierarchical
structure in the group. At first glance, this argument could indicate
that such projects are not candidates for the use of agile methods
since some basic values (such as distance between developers) seem to
be missing. However, most open source projects share some principles
with the agile manifesto \cite{AgileManifesto}. Being ready for
changes, working with continuous feedback, delivering real features,
respecting collaborators and users and facing challenges are expected
attitudes from agile developers naturally found in the Free and Open
Source Software (FOSS) communities.

In this work, any software engineering method that follows the
principles of the agile manifesto \cite{AgileManifesto} is considered
an agile method. Focus will be given on the most known methods, such
as eXtreme Programming (XP) \cite{XP02}, Scrum \cite{Schwaber2004} and
the Crystal family \cite{Cockburn2002}.

``Open source'' is slightly more complicated to define. This work will
consider the terms ``Open source software'' and ``Free software'' the
same although they have important differences in their specific
contexts \cite[Ch. 1, Free Versus Open source]{Fogel2005}. Projects
will be considered to be open source (or free) if their source code is
available and modifiable by anyone with the required technical
knowledge, without prior consent from the original author and without
any charge. Note that this definition is closer from the free software
idea than the open source one.

Another restriction will be that projects started and controlled by a
company do not fit in this definition of OS. That is because projects
controlled by companies, whether they have a public source code and
accept external collaboration or not, can be run with any software
engineering method since the company can enforce it to its
employees. Some methods will work better to attract external
contributions but the company still controls its own team and can
maintain the software without external collaboration.

\section{Is Open source Agile?}
\label{sec:foss}

OS communities could almost be considered agile and they indeed were
by Martin Fowler in his first version of ``The New Methodology''
\cite{Fowler00orig}. The methods that Eric Raymond describes in ``The
Cathedral and the Bazaar'' \cite{Raymond1999} lack a more precise
definition but several ideas could be related to the agile manifesto
\cite{AgileManifesto}.

Reis \cite{Reis2003} shows that 65\% of the studied projects use
version control software, the project website and mailing lists as the
most used tools to communicate with the users and in the team. Those
\textbf{tools and processes} are kept as simple as possible in order
to promote the inclusion of new \textbf{individuals that interact}
with the existing community to produce new software.

Recently, Oram \cite{Oram2007} presented the results of a survey
conducted by O'Reilly showing that free documentation is increasingly
being written by volunteers. It means that \textbf{comprehensive
  documentation} grows with the community around the \textbf{working
  software}, as users encounter problems to complete a specific
action. According to Oram's work, contributors tend to write
documentation for their personal growth or to improve the community of
the existing software.

A search on Google for ``Development Roadmap open source'' returned
more than 282.000 results on 3/3/2009 showing that open source project
tend to have a plan.  However, \textbf{following those plans} is not a
rule. The \textbf{ability of each project to adapt and respond to
  changes} is what separates succesful free software from failed ones.

Communities created around FOSS projects involve users, developers,
and sometimes even clients working together to craft the best software
possible. The absence of such community around a program usually
denounces a recent project or one that is dying. Raymond's description
\cite{Raymond1999} of an OSS process does not present guide lines or
practices that a development team can follow. This makes it harder to
state that OS is agile but surely shows that the two worls are
related.

\section{Agile contributions to improve Open Source}
\label{sec:agile-improve-os}

Most of the problems pointed out so far are related to communication
issues caused by the amount of people involved in a project and their
various knowledge and cultures. Although in OS those matters are taken
to a limit, distributed agile teams face some of the same problems
\cite{Sutherland2007,Maurer2002}.

As Beck suggests \cite{Beck2008}, tools can improve the adoption and
use of agile practices and, therefore, improve a development
process. A fair amount of work has been directed to distributed pair
programming tools\footnote{http://sf.net/projects/xpairtise/ - Last
  accessed 02/10/2008} and studies \cite{Nagappan2003} but very few
tools have been produced to support other practices. Since
communication is at stake, a few other practices are related to it in
agile methods. The following subsections will present those practices
and the tools to improve the OS experience with agile development.

\subsubsection{Informative Workspace}
\label{subsec:inform-worksp}

This practice suggests that an agile team should work in an
environment that gives them information regarding their work. Beck
assigns a specific role, the tracker role, to the person (or persons)
that should maintain this information available and updated to the
team. With co-located teams, the tracker usually collects metrics
\cite{Sato2007} automatically and selects a few of them to present in
the workspace. Most of the objective metrics are related to the code
base while subjective ones depend on developers' opinions.

Collecting those data is not a hard task but it is usually time
consuming and does not produce immediate benefit to the software.
This is probably the reason why it is very rare to find an OS project
with updated metrics and data in their website. A tool that could
improve such scenario would be a web-based plug in system with a
built-in metrics collection as well as a way to add and present new
metrics. Such tool should be available into OS forge applications to
allow projects to easily connect them to their repository and web
site.

\subsubsection{Stories}
\label{subsec:stories}

Regarding the planning system, XP suggests that requirements should be
collected in user story cards. The goal is to minimize the amount of
effort required to discover the next step to make and being able to
easily change those requirements priorities over time. OS projects
usually are based on bug tracking systems to store those
requirements. A missing feature is reported as a bug that should be
corrected and discussions and patch suggestions are submitted related
to that ``bug''. The problem with this approach is that changing
priority and setting a release plan is very time consuming and relies
on non documented assumptions (such as ``this release should solve
buts with priority over 8'').  It is also very hard to obtain an
overall view of all the requirements.

Discovering what are the main priorities for the team quickly and
being able to change those priorities according to the community's
feedback is key to develop a working software. To help achieve this, a
tool should be implemented to allow bugs to be seen as movable
elements on a release planning. In order to benefit from the
community's knowledge, the tool should also have the bug's priority
and content set by the users in a similar way as Wikipedia manages its
articles \cite{Benkler2006}.

\subsubsection{Retrospective}
\label{subsec:retrospect}

This practice suggests that the team should get together in a physical
place periodically to discuss the way the project is going. There are
two issues in such practice in OS software teams. The first one is to
have all members of the team present at the same time. The second one
is to have them interact collectively in a shared area placing notes
on time stating problems and good things they felt.

When the team is co-located, this is usually done in a meeting room
with a huge time line and coloured post-its. Our suggestion is to
develop a web-based tool to allow such interaction relating the time
line to the code repository base. The team would be able to annotate
asynchronously the time line. The team leader would occasionally
generate a report sent to all members as well as posted in the
informative workspace.

\subsubsection{Stand up meetings}
\label{subsec:stand-up}

Stand up meetings, originally suggested in the Scrum methodology,
demands that the whole team gets together and each member explains
quickly what they have been doing and intend to do. This practice
shares the same problem as the retrospective. It involves having the
team together at the same time. Several OS projects already have a
partial solution to this practice using an IRC channel to centralize
the discussions during development time. Although it does not ensure
everyone gets to know what other members are doing, it helps
synchronizing work.

To ensure members get the required knowledge, we suggest that those
IRC channels should be logged and should present the last few messages
to newcomers at every log in. It should also be possible for members
to leave notes from that channel to the bug tracking system as well as
messages to other contributors. On IRC channel, this sort of solution
would usually be implemented by a bot which we intend to associate to
the forge system that should host the previous features.

\section{Conclusion}
\label{sec:conclusion}

In this preliminary work we have shown several evidences that a
synergy between agile methods and OS can improve software development
on FOSS projects. Several projects already adopt some agile techniques
to be more responsive to users but a complete description of a method
that considers all FOSS factors would surely increase adoption in
those communities. On the other hand, solving the problem is a
challenge that would consolidate agile methods to a distributed
environment relying on a large user community.

As part of this work, two surveys are planned. One to be conducted at
FISL (International Free Software Forum) 2009 to understand how much
OS developers and enthusiasts know about agile methods and what keeps
them from using them. The other one to be conducted at Agile 2009 will
try to discover how involved is the agile community with OS
development. Both surveys will be used to provide a deeper
understanding of the interaction between both communities and how to
improve it.

\section{Acknowledgements}

This work was supported by the QualiPSo project \cite{Qualipso}. We
would like to thank Christian Reis for his help, interesting
discussions and support as well as Danilo T. Sato and Mariana V. Bravo
for reviewing this work.

\bibliographystyle{plain} \bibliography{./biblio}

\end{document}
